spring:
  application:
    name: product
  cloud:
    config:  #配置中心需要
      discovery:
        enabled: true
        service-id: config
      profile: dev
      label: master
    stream:  #整合steam
      bindings:
        myOutput:
          destination: mex  #绑定交换机
          producer:
            ttl: 3000 #消息3秒不消费转入私信队列
            autoBindDlq: true #启动私信队列
            deadLetterExchange: mex #绑定exchange
            deadLetterQueueName: mex.myOutput #死信队列名字：exchanName.queueName
        myInput:
          destination: mex
          group: product-in #分组
          content-type: application/json  #将消息json显示在监控台
          consumer:
            max-attempts: 2
            autoBindDlq: true #启用死信队列，默认会生成一个DLX EXCHANGE，当消息重复消费失败后
            dlqDeadLetterExchange: input-deadLetter.DLX  #如果该列声明，那么deadLetterExchange也要声明，这个保持一致
            deadLetterExchange: input-deadLetter.DLX #与dlqDeadLetterExchange保持一致
            requeueRejected: true
#    rabbit:
#      bindings:
#        myOutput:
#          producer:
#            ttl: 3000 #消息3秒不消费转入私信队列
#            autoBindDlq: true #启动私信队列
#            deadLetterExchange: myInput #绑定exchange
#            deadLetterQueueName: myInput.product-in #死信队列名字：exchanName.queueName

eureka:
  client:
    service-url:
      defaultZone: http://localhost:8761/eureka/  #服务中心的地址
management:
  endpoints:
    web:
      exposure:
        include:  bus-refresh # 暴露bus-refresh为了接到通知
    ## 消息发送确认(用来确认生产者将消息发送给交换器,交换器传递给队列的过程中,消息是否成功投递)
    #publisher-confirms=true
    ## 消息发送失败退回(消息投递失败时触发)
    #spring.rabbitmq.publisher-returns=true
    ## 消息接收确认,采用手动应答(none 不确认;auto 自动确认;manual 手动确认)
    #spring.rabbitmq.listener.simple.acknowledge-mode=manual
    ## 并发消费数量
    #spring.rabbitmq.listener.simple.concurrency=5
    ## 最大并发消费数量
    #spring.rabbitmq.listener.simple.max-concurrency=10

